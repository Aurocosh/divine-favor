import org.gradle.internal.os.OperatingSystem
import org.jetbrains.gradle.ext.Gradle

plugins {
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.1.7'
    id 'com.gtnewhorizons.retrofuturagradle' version '1.3.36'
    id 'com.matthewprenger.cursegradle' version '1.4.0'
    id 'org.jetbrains.kotlin.jvm' version '1.9.24'
    id 'org.jetbrains.kotlin.plugin.serialization' version '1.9.24'
}

repositories {
    mavenCentral()
    maven {
        name = "forge"
        url = "https://maven.minecraftforge.net/"
    }
    maven {
        name 'CurseMaven'
        url 'https://cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    maven {
        name 'CleanroomMC Maven'
        url 'https://maven.cleanroommc.com'
    }
    maven {
        // location of the maven that hosts JEI files
        name = "Progwml6 maven"
        url = "https://dvs1.progwml6.com/files/maven/"
    }
//    maven {
//        // location of a maven mirror for JEI files, as a fallback
//        name = "ModMaven"
//        url = "https://modmaven.dev"
//    }
    maven { // TOP
        name 'tterrag maven'
        url "https://maven.tterrag.com/"
    }
    maven { // Patchouli
        url 'https://maven.blamejared.com'
    }
    mavenLocal()
}

//logging.level = LogLevel.DEBUG
//def currentReleaseType = getReleaseType()
version = "${mod_version}.${generateVersionCode()}"
def localDependencies = getEnvVar('LOCAL_DEPENDENCIES').toBoolean()

println "Mod version: $version"
println "Release type: $release_type"
println "Local dependencies: $localDependencies"
//println generateChangeLog('release')

group = mod_group
archivesBaseName = mod_archives_base_name

// Set the toolchain version to decouple the Java we run Gradle with from the Java used to compile and run the mod
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(8))
        // Azul covers the most platforms for Java 8 toolchains, crucially including MacOS arm64
        vendor.set(JvmVendorSpec.AZUL)
    }
    // Generate sources and javadocs jars when building and publishing
//    withSourcesJar()
//    withJavadocJar()
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

minecraft {
    mcVersion = '1.12.2'

    // MCP Mappings
    mcpMappingChannel = 'stable'
    mcpMappingVersion = '39'

    // Set username here, the UUID will be looked up automatically
    username = 'Aurocosh'

    // Add any properties you want to swap out for a dynamic value at build time here
    // Any properties here will be added to a class at build time, the name can be configured below
    // Example:
    injectedTags.put('VERSION', project.version)
}

// Generate a group.archives_base_name.Tags class
tasks.injectTags.configure {
    // Change Tags class' name here:
    outputClassName.set("${mod_group}.${mod_archives_base_name.toLowerCase()}.Tags")
}

dependencies {
    // Forgelin
    implementation 'curse.maven:forgelin-continuous-456403:5361696'

    // compile against the JEI API but do not include it at runtime
    api rfg.deobf("mezz.jei:jei_${mc_sub_version}:${jei_version}:api")
    // at runtime, use the full JEI jar
    runtimeOnly "mezz.jei:jei_${mc_sub_version}:${jei_version}"

    // CraftTweaker
    implementation rfg.deobf("com.blamejared:MTLib:${mt_version}")
    implementation(rfg.deobf("CraftTweaker2:CraftTweaker2-MC1120-Main:1.12-${ct_version}")) {
        exclude module: "gson"
    }

    // Chisel
    api rfg.deobf("team.chisel.ctm:CTM:MC${mc_sub_version}-${ctm_version}:api")

    // Patchouli
    implementation rfg.deobf("vazkii.patchouli:Patchouli:${p_version}")

//    if (!localDependencies)
//        implementation "aurocosh.autonetworklib:autonetworklib-${mc_sub_version}:${auto_network_version}"
}

processResources {
    // This will ensure that this task is redone when the versions change
    inputs.property 'version', project.version
    inputs.property 'mcversion', project.minecraft.version

    // Replace various properties in mcmod.info and pack.mcmeta if applicable
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        // Replace version and mcversion
        fcd.expand (
                'version': project.version,
                'mcversion': project.minecraft.version
        )
    }
}

static def generateVersionCode() {
    return shExec("git rev-list HEAD --count").toInteger()
}

//static def getReleaseType() {
//    def tags = shExec("git notes show", true, true)
//    def isRelease = tags.contains('release')
//    (isRelease) ? "release" : "beta"
//}

static def generateChangeLog(releaseType) {
    def currentChange = shExec("git log --format=%B -n 1 HEAD")
    if (releaseType == 'beta')
        return currentChange

    def logWithNotes = shExec("git log origin/master --format=%H_%N")
    def matches = logWithNotes =~ '([0-9a-f]{5,40})_.*release'
    def lastReleaseHash = matches[1][1]

    def logFromPreviousBetas = shExec("git log --format=%s $lastReleaseHash..HEAD~1", true)
    return "Last change:\n$currentChange\n\nChangelog from previous beta versions:\n$logFromPreviousBetas"
}

static def shExec(command, ignoreEmptyResult = false, ignoreErrors = false) {
    if (OperatingSystem.current().isLinux())
        command = command.replaceAll('"', '\\\\"')

    def resultBuilder = '' << ''
    def errorsBuilder = '' << ''
    def task = command.execute()
    task.waitForProcessOutput(resultBuilder, errorsBuilder)

    def result = resultBuilder.toString().trim()
    def errors = errorsBuilder.toString().trim()
    if ((result.empty && !ignoreEmptyResult) || (!errors.empty && !ignoreErrors))
        throw new RuntimeException("Could not execute command $command. Cmd output: $result. Errors: $errors")
    return result
}

static def getEnvVar(varName,fallback = '') {
    def value = System.getenv(varName)
    return value ? value : fallback
}

curseforge {
    apiKey = getEnvVar('CURSEFORGE_API_KEY')
    project {
        id = curse_project_id
        changelog = generateChangeLog(release_type)
        releaseType = release_type
        relations {
            requiredDependency 'forgelin_continuous'
            requiredDependency 'patchouli'
            optionalDependency 'jei'
            optionalDependency 'crafttweaker'
            optionalDependency 'mtlib'
            optionalDependency 'max-potion-id-extender'
        }
    }
}


idea {
    module {
        inheritOutputDirs true
        downloadJavadoc true
        downloadSources true
    }
    project {
        settings {
            runConfigurations {
                '1. Setup Workspace'(Gradle) {
                    taskNames = ['setupDecompWorkspace']
                }
                '2. Run Client'(Gradle) {
                    taskNames = ['runClient']
                }
                '3. Run Server'(Gradle) {
                    taskNames = ['runServer']
                }
                '4. Run Obfuscated Client'(Gradle) {
                    taskNames = ['runObfClient']
                }
                '5. Run Obfuscated Server'(Gradle) {
                    taskNames = ['runObfServer']
                }
                '6. Build Jars'(Gradle) {
                    taskNames = ['build']
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = '-encoding utf8'
                    moduleJavacAdditionalOptions = [
                            (project.name + ".main"): tasks.compileJava.options.compilerArgs.collect { '"' + it + '"' }.join(' ')
                    ]
                }
            }
        }
    }
}

tasks.named("processIdeaSettings").configure {
    dependsOn("injectTags")
}